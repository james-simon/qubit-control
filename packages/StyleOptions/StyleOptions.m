(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* :Title: StyleOptions *)
(* :Context: StyleOptions` *)
(* :Author: Mark A. Caprio, Department of Physics, University of Notre Dame *)
(* :Summary: Styles with inheritance. *)
(* :Copyright: Copyright 2014, Mark A. Caprio *)
(* :Package Version: 0.99 *)
(* :Mathematica Version: 6.0 *)
(* :History:
Based on code from SciDraw beta, January 3, 2012.
December 20, 2013. Add ShowStyles[].
January 30, 2014. Add ClearStyles[].
February 20, 2014. Overhaul syntax for combining styles and process for resolving styles, including adding add MakeStyle[].  Remove reversal of precedence, so now earlier options take precedence.
June 6, 2014. Rename MakeStyle[] to StyleUnion[].
 *)


BeginPackage["StyleOptions`"];


Unprotect[Evaluate[$Context<>"*"]];


StyleOptions::usage="StyleOptions[style] returns the options associated with style, for all symbols, as a list of rules of the form {symbol1\[Rule]options1,...}.  StyleOptions[style,symbol] retrieves those options associated specifically with the given symbol.";
StyleQ::usage="StyleQ[style] returns True if and only if the expression style resolves to a valid style name.";
WithStyle::usage="WithStyle[style,body] or WithStyle[{style1,...},body] evaluates body with the default options set according to the given style or styles.  This is accomplished using WithOptions.";
StyleUnion::usage="StyleUnion[expr] represents a composite style, where expr should have the same form as described for DefineStyle, e.g., {symbol1->optionlist1,symbol2->optionlist2,...,parent1,parent2}.";
MakeStyle::usage="MakeStyle is old name for StyleUnion.  (LEGACY SUPPORT)";
StyleSpecifierPattern::usage="StyleSpecifierPattern is a pattern which matches None, a style name, or a StyleUnion expression.  An argument matching this form is appropriate as the argument to StyleOptions or WithStyle.";


DefineStyle::usage="DefineStyle[style,expr] defines a new style, where the style name may itself involve named patterns, which serve as arguments to expr.  The expression expr should evaluate to a list of the form  {symbol1->optionlist1,symbol2->optionlist2,...}, where other (parent) style names may be interspersed, e.g., {symbol1->optionlist1,symbol2->optionlist2,...,parent1,parent2}.  Earlier rules or parent styles take precedence over later rules or styles in final combined rule list.";
ShowStyles::usage="ShowStyles[] displays all current style definitions.  This is meant for diagnostic purposes.";
ClearStyles::usage="ClearStyles[] clears all current style definitions.  This is meant for diagnostic purposes.";


Begin["`Private`"];


Needs["BlockOptions`"];
Needs["InheritOptions`"];  (* for OptionsUnion[] *)


General::argsexpr="Missing or unexpected arguments in `1`.";
General::argsnull="One of the arguments in `1` is Null.  Check for extra commas among the arguments.";


ThrowMessage[f_Symbol,m_String,Args___]:=Message[MessageName[f,m],Args];


SetAttributes[FallThroughError,HoldRest];
FallThroughError[Self_Symbol,Expr_]:=Module[
{},
If[
Count[Hold[Expr],Null,{2}]>0,
ThrowMessage[Self,"argsnull",HoldForm[Expr]],
ThrowMessage[Self,"argsexpr",HoldForm[Expr]]
];
$Failed
];


DeclareFallThroughError[f_Symbol]:=(Expr:HoldPattern[f[___]]:=FallThroughError[f,Expr]);


SetAttributes[DefineStyle,{HoldRest}];


DefineStyle[Name_,Function_]:=Module[
{},
StyleDefinitionFlag[Name]=True;
StyleDefinition[Name]:=Function;
];
DeclareFallThroughError[DefineStyle];


StyleQ[Name_]:=TrueQ[StyleDefinitionFlag[Name]];


StyleSpecifierPattern=None|(_?StyleQ)|StyleUnion[_List];
ValidStyleListPattern={(StyleSpecifierPattern|Rule[_Symbol,{Rule[(_Symbol)|(_String),_]...}])...};  (* detailed check on optionlist argument for validation *)


ListSyntaxReminder="  It should be should be a list containing entries matching symbol1->options1, a defined style, StyleUnion[{...}], or None.";


StyleOptions::undef="Style specifier `1` does not match any defined style, StyleUnion[{...}], or None.";
StyleOptions::stylebadvaluerule=
StringJoin[
"Style `1` has been resolved to an invalid expression, consisting of a single rule `2`.",
ListSyntaxReminder,
"\n\n(COMMON CAUSE: You may have forgotten to give the style option rules as a list when you defined the style.  If you gave DefineStyle[style,symbol->options], this should be changed to DefineStyle[style,{symbol->options}].  The general syntax is DefineStyle[style,{symbol1->options1,...}].)"
];
  StyleOptions::stylebadvalue=StringJoin[
"Style `1` has been resolved to an invalid expression `2`.",
ListSyntaxReminder
];
StyleOptions::listbadvalue=
StringJoin[
"The list `1` given to StyleUnion contains one or more invalid entries.",
ListSyntaxReminder
];


MergeStyleOptions[RawStyleOptions_List]:=Module[
{ReversedStyleOptions},

(* FORMERLY -- reverse order, so latter styles have priority over earlier styles in final combined rule list *)
(*ReversedStyleOptions=Reverse[RawStyleOptions];*)

(* merge multiple specifications for same symbol *)
(* CAVEAT: See notes in InheritOptions.nb on ordering issues in use of Sort. *)
Cases[
SplitBy[Sort[RawStyleOptions,OrderedQ[{First[#1],First[#2]}]&],First],
(rseq:{(s_Symbol->_List)..}):>(s->OptionsUnion[Last/@rseq])
]
];


ResolveStyleOptions[Name:None]={};


ResolveStyleOptions[Name_?StyleQ]:=Module[
{StyleList},

(* evaluate options list*)
StyleList=StyleDefinition[Name];

(* validate options list so far *)
(* it is good to do this now, while we still remember the style name and can give it in the error message *)
(* first trap common error with helpful message *)
If[
MatchQ[StyleList,_Rule],
Message[StyleOptions::stylebadvaluerule,Name,StyleList];
Return[{}]
];
(* do generic validation *)
If[
!MatchQ[StyleList,ValidStyleListPattern],
Message[StyleOptions::stylebadvalue,Name,StyleList];
Return[{}]
];

(* recursively resolve any entries which are not rules and flatten *)
Flatten[Replace[
StyleList,
(x:Except[_Rule]):>ResolveStyleOptions[x],
{1}
]]

];


ResolveStyleOptions[StyleUnion[StyleList_List]]:=Module[
{SplicedStyleList},

(* validate explicit options lists, i.e., not those yet to be extracted from parent styles *)
If[
!MatchQ[StyleList,ValidStyleListPattern],
Message[StyleOptions::listbadvalue,StyleList];
Return[{}]
];

(* recursively resolve any entries which are not rules and flatten *)
Flatten[Replace[
StyleList,
(x:Except[_Rule]):>ResolveStyleOptions[x],
{1}
]]

];


MakeStyle::deprecated="MakeStyle has been renamed to StyleUnion.";
MakeStyle:=(Message[MakeStyle::deprecated];StyleUnion);


StyleOptions[StyleSpecifier:StyleSpecifierPattern]:=Module[
{},
MergeStyleOptions[ResolveStyleOptions[StyleSpecifier]]
];


StyleOptions[StyleSpecifier:StyleSpecifierPattern,s_Symbol]:=Module[
{FullStyleOptions},
FullStyleOptions=Append[ResolveStyleOptions[StyleSpecifier],(_->{})];
Replace[s,FullStyleOptions]
];


StyleOptions[Junk:Except[StyleSpecifierPattern],s:_Symbol:None]:=Module[
{},
ThrowMessage[StyleOptions,"undef",Junk];
$Failed
];


DeclareFallThroughError[StyleOptions];


SetAttributes[WithStyle,HoldRest];


WithStyle[StyleSpecifier:StyleSpecifierPattern,Body_]:=Module[
{},

(* apply options and evaluate body *)
WithOptions[
StyleOptions[StyleSpecifier],
Body
]

];
DeclareFallThroughError[WithStyle];


ShowStyles[]:=Module[
{},

Definition[StyleDefinition]

];
DeclareFallThroughError[ShowStyles];


ClearStyles[]:=Module[
{},

Clear[StyleDefinition]

];
DeclareFallThroughError[ClearStyles];


End[];


Protect[Evaluate[$Context<>"*"]];
EndPackage[];
